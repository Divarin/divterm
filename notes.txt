buffer:
...................................................................................
^            ^                ^        ^                                          ^
start (bs)   |                |        |                                          start + length (bs + BUFFER_LEN)
             |                |        write pointer (wp)
			 |   			  read pointer (rp)
			 scrollback limit pointer (slp)
							  
[non-pause mode]
get char from "modem".
increment write pointer (wp) but wrap around on overflow:
	wp++;
	if (wp >= bs+BUFFER_LEN) wp = bs;

write char into buffer:
	*wp = chr;

[on activate pause mode]
set read pointer to current write pointer:
	rp = wp;

set scrollback limit pointer (slp) to read pointer - 2000 bytes.  This makes sure that the previous 2000 characters cannot be overwritten by the write pointer as new data is coming in while in pause mode.
	slp=rp-2000;
	if (slp < bs)
		slp = (bs + BUFFER_LEN) - (slp-bs); // wrap around to the end

get char from "modem".
check that wp isn't at the scrollback limit pointer, if not then increment write pointer and write the byte into the buffer:
	if (wp != slp) {
		wp++;
		*wp = chr;
	}
otherwise no more data is buffered

[while scrolling down]
see if there is any new data beyond the current read pointer. (if not then rp and sp are the same)
if there is, then read in up to one line of text and print it out	
	for (i=0; i < VIC ? 40 : 80 && rp != wp; i++) { // get 40 or 80 chars from the buffer (depending on video mode)
		rp++; // try advancing the read pointer once
		if (rp >= bs+BUFFER_LEN) rp = bs; // if necessary wrap around to the start of the buffer
		if (rp == wp) break; // if we've advanced up to the write pointer, no more buffered data in this direction
		putchar(*rp); // otherwise write the character
	}

[while scrolling up]
this is similar to scrolling down but much more difficult to pull off visually.
First, we need to figure out where to position the read pointer since we have a full screen of text already (maybe)
	* try to move back the read pointer to top of screen (one screen page's worth of characters) + scrollback_size
	* as you move the rp, check to not go beyond the limit pointer (slp)
	* also check if we need to wrap back to end
	
Then we need to shift everything down to provide one blank line at the top of the screen.  there is a SYS for doing this 
	* screw that, instead clear the screen and re-draw scrollback_size amount of text starting at rp
	
on the VIC, i don't know about the VDC.  We may need to re-draw the whole screen.
Then we need to position the cursor at the top (I guess print "home" should do that)
Then print and hope it doesn't overwrite.

It might be easier to just re-draw and let things scroll up as normal, sort of like the "page up" option in Community.

	